[TOC]

进程管理

![img](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/3-%E6%8F%90%E7%BA%B2.jpg)

# 5.1 进程 

## 5.1.1 并发 与 并行



![并发与并行](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/5-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C.jpg)

- 进程的运行状态

  ![进程五种状态的变迁](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/8-%E8%BF%9B%E7%A8%8B%E4%BA%94%E4%B8%AA%E7%8A%B6%E6%80%81.jpg)

- 防止阻塞进程 占用 物理内存 

  - 阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；

  - 就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行；

​         这两种挂起状态加上前面的五种状态，就变成了七种状态变迁（留给我的颜色不多了），见如下图：

![七种状态变迁](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/10-%E8%BF%9B%E7%A8%8B%E4%B8%83%E4%B8%AD%E7%8A%B6%E6%80%81.jpg)

## 5.1.2 进程控制结构 

- （*process control block，PCB*）
- 内容
  - **进程描述信息：**
    - 进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；
    - 用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；
  - **进程控制和管理信息：**
    - 进程当前状态，如 new、ready、running、waiting 或 blocked 等；
    - 进程优先级：进程抢占 CPU 时的优先级；
  - **资源分配清单：**
    - 有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。
  - **CPU 相关信息：**
    - CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。

- 多进程的结构
  - 通过**链表**的方式进行组织，把具有**相同状态的进程链在一起，组成各种队列**。比如：
    - 将所有处于就绪状态的进程链在一起，称为**就绪队列**；
    - 把所有因等待某事件而处于等待状态的进程链在一起就组成各种**阻塞队列**；
    - 另外，对于运行队列在单核 CPU 系统中则只有一个运行指针了，因为单核 CPU 在某个时间，只能运行一个程序。
  - ![image-20231215083525993](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/image-20231215083525993.png)

- 进程切换

  - CPU上下文

    - CPU上下文（Context）是指在执行程序时，CPU所需的当前状态和寄存器的内容。
    - CPU上下文通常包括以下内容：
      1. **程序计数器（PC）：** 指示下一条要执行的指令的地址。
      2. **寄存器值：** 包括通用寄存器、堆栈指针、帧指针等。
      3. **标志位：** 存储有关算术运算和逻辑运算的状态信息的标志寄存器。
      4. **堆栈：** 存储函数调用和局部变量的内存区域。
      5. **其他状态信息：** 比如处理器模式（内核模式或用户模式）、中断屏蔽位等。

  - 切换

    - ![进程上下文切换](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/13-%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2.jpg)

    - **进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。**

# 5.2 线程

- **为什么引入线程**
  - 进程 无法满足 在同一地址空间内；并发执行
    - 进程可以并发执行，但是进行多段连续操作时，不共享地址空间 就会导致无效并发！
  - **线程( Thread )**，线程之间可以并发运行且共享相同的地址空间

- **线程的执行**

  ![多线程](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/16-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.jpg)

- **线程优缺点**

  - 优点
    - 一个进程中可以同时存在多个线程；
    - 各个线程之间可以并发执行；
    - 各个线程之间可以共享地址空间和文件等资源；
  - 缺点
    - 当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃

- **线程的上下文切换**

  - **线程是不是属于同一个进程**：
    - 否
      - 当两个线程不是属于同一个进程，则**切换的过程就跟进程上下文切换一样；**
    - 是
      - **当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据**；

- **线程实现**

  - **用户线程（User Thread）**：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；

    ![多对一](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/17-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B-%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB.jpg)

    - ![用户级线程模型](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/20-%E7%BA%BF%E7%A8%8BPCB-%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB.jpg)

  - **内核线程（Kernel Thread）**：在内核中实现的线程，是由内核管理的线程；

    ![一对一](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/18-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B-%E4%B8%80%E5%AF%B9%E4%B8%80%E5%85%B3%E7%B3%BB.jpg)![内核线程模型](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/21-%E7%BA%BF%E7%A8%8BPCB-%E4%B8%80%E5%AF%B9%E4%B8%80%E5%85%B3%E7%B3%BB.jpg)

  - **轻量级进程（LightWeight Process）**：在内核中来支持用户线程；

​				![多对多](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/19-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB.jpg)

![LWP 模型](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/22-LWP.jpg)

# 5.3 进程线程对比

| 特点               | 进程                                                         | 线程                                                     |
| ------------------ | ------------------------------------------------------------ | -------------------------------------------------------- |
| **资源分配**       | **资源分配的基本单位**，拥有独立的内存空间、文件描述符等资源 | **进程内执行单元**，共享相同的进程资源，如内存空间和文件 |
| **创建和销毁开销** | 创建和销毁开销相对较大                                       | 创建和销毁开销相对较小                                   |
| **切换开销**       | 切换开销较大，需要切换页表                                   | 切换开销较小，无需切换页表                               |
| **通信效率**       | 通信需要经过内核，开销相对较大                               | 数据传递更为高效，无需通过内核                           |
| **并发执行**       | 受到多个进程间通信的开销和限制，相对较复杂                   | 更有效地利用多核处理器，提高并发执行效率                 |

**对于线程和进程，我们可以这么理解**：

- 当进程只有一个线程时，可以认为进程就等于线程；
- 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源，这些资源在上下文切换时是不需要修改的；

# 5.4 调度

**操作系统的调度单位是 线程， 说的是进程调度，起始调度的是 进程中的主线程**

## 5.4.1 调度方式

- **非抢占式**
  - 挑选一个进程，然后让该进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程
- **抢占式**
  - 挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程。**（时间片轮转）**

## 5.4.2 调度原则

![五种调度原则](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/23-%E4%BA%94%E7%A7%8D%E8%B0%83%E5%BA%A6%E8%A7%84%E5%88%99.jpg)

- **CPU 利用率**：调度程序应确保 CPU 是始终匆忙的状态，这可提高 CPU 的利用率；
- **系统吞吐量**：吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量；
- **周转时间**：周转时间是进程运行+阻塞时间+等待时间的总和，一个进程的周转时间越小越好；
- **等待时间**：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意；
- **响应时间**：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准。

# 5.5 进程通信

![img](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/3-%E6%8F%90%E7%BA%B2-1702692628656-17.jpg)

## 5.5.1 管道  （内核中的一串缓存）

- 匿名管道

  - `|` 管道符 

- 命名管道

  - `mkfifo`  创建

    - ```bash
      $ mkfifo myPipe
      ```

  -  管道使用

    - ```bash
      echo "hello" > myPipe  // 将数据写进管道
                               // 停住了 ...
                               
      $ cat < myPipe  // 读取管道里的数据
      hello
      
      //读取数据后才能结束 echo
      ```

- 不足
  - 效率低 不适合频繁访问

## 5.5.2 消息队列    （内核中的消息链表）

- 不足
  - 传递不及时
  - 大小有限制
  - 用户态 和 内核态 之间通信 开销大

## 5.5.3 共享内存  （虚拟内存 映射到 同一物理内存）

![img](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/9-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98.jpg)

- **新增功能**
  - 解决 用户态 和  内核态 之间的 拷贝问题
- **不足**
  - 多进程同时修改，引发冲突

## 5.5.4 信号量  （控制 共享内存 的 访问成员）

- **新增功能**
  - 引入信号量 进行 同步 与 互斥 操作 ，解决 共享内存 之间的冲突问题
- **实现原理**
  - 进程 进共享内存 P操作
  - 进程 出共享内存 V操作
  - ![img](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/10-%E4%BF%A1%E5%8F%B7%E9%87%8F-%E4%BA%92%E6%96%A5.jpg)

![img](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/11-%E4%BF%A1%E5%8F%B7%E9%87%8F-%E5%90%8C%E6%AD%A5.jpg)

## 5.5.5 信号  （**唯一的异步通信机制**）

- 异常状态 下的  使用信号 进行通知
- 作用
  - 软件 中断 
  - 处理 异常事件

## 5.5.6 Socket

- **新增功能**

  - 不同设备之间的 进程通信

  ![img](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/12-TCP%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B.jpg)

## 5.5.7 总结 

![image-20231216110408089](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/image-20231216110408089.png)

# 5.6 线程冲突

![img](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/2-%E6%8F%90%E7%BA%B2.jpg)

## 5.6.1 互斥

互斥 ，**保证一个线程在临界区执行时，其他线程应该被阻止进入临界区**

![互斥](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/10-%E4%B8%B4%E7%95%8C%E5%8C%BA.jpg)

## 5.6.2 同步

​		**同步，就是并发进程/线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程/线程同步**

![吃饭与做菜的同步关系](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/11-%E5%90%83%E9%A5%AD%E5%90%8C%E6%AD%A5.jpg)

## 5.6.3 互斥 和 同步的区别

- 同步就好比
  - 「操作 A 应在操作 B 之前执行」，「操作 C 必须在操作 A 和操作 B 都完成之后才能执行」等；
- 互斥就好比
  - 「操作 A 和操作 B 不能在同一时刻执行」

## 5.6.4 互斥 与 同步的 实现

- *锁*：加锁、解锁操作；
  - 「忙等待锁」
    - 当获取不到锁时，线程就会一直 while 循环，不做任何事情，所以就被称为「忙等待锁」，也被称为**自旋锁（\*spin lock\*）**。
    - ![img](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/14-%E8%87%AA%E6%97%8B%E9%94%81.jpg)
  - 「无忙等待锁」
    - 无等待锁顾明思议就是获取不到锁的时候，不用自旋。
    - ![img](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/15-%E6%97%A0%E7%AD%89%E5%BE%85%E9%94%81.jpg)
- *信号量*：P、V 操作；

- 对于两个并发线程，互斥信号量的值仅取 1、0 和 -1 三个值，分别表示：

  - 如果互斥信号量为 1，表示没有线程进入临界区；

  - 如果互斥信号量为 0，表示有一个线程进入临界区；

  - 如果互斥信号量为 -1，表示一个线程进入临界区，另一个线程等待进入。

- 2 个资源的信号量，相当于 2 条火车轨道，PV 操作如下图过程

![信号量与火车轨道](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/16-%E7%81%AB%E8%BD%A6PV%E6%93%8D%E4%BD%9C.jpg)

![PV 操作的算法描述](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/17-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FPV%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0.jpg)

-  信号量 同步   

  - 一个 信号量 初始值 为 0 

  - ![img](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/19-%E4%BA%92%E6%96%A5%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%90%8C%E6%AD%A5%E5%AE%9E%E7%8E%B0-%E5%90%83%E9%A5%AD%E4%BE%8B%E5%AD%90.jpg)

## 5.6.5 互斥 与 同步 例子

- **生产者 和 消费者 问题**

  - ![生产者-消费者模型](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/20-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85.jpg)

  - **分析**
    - 任何时刻只能有一个线程操作缓冲区，说明操作缓冲区是临界代码，**需要互斥**；
    - 缓冲区空时，消费者必须等待生产者生成数据；缓冲区满时，生产者必须等待消费者取出数据。说明生产者和消费者**需要同步**。

  - **结果**
    - 互斥信号量 `mutex`：用于互斥访问缓冲区，初始化值为 1；
    - 资源信号量 `fullBuffers`：用于消费者询问缓冲区是否有数据，有数据则读取数据，初始化值为 0（表明缓冲区一开始为空）；
    - 资源信号量 `emptyBuffers`：用于生产者询问缓冲区是否有空位，有空位则生成数据，初始化值为 n （缓冲区大小）；

- **哲学家问题**
  - ![哲学家就餐的问题](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/23-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E6%A8%A1%E5%9E%8B.jpg)
  - ![方案四也可解决问题](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/31-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90-%E6%96%B9%E6%A1%88%E5%9B%9B-%E5%9B%BE%E8%A7%A3.jpg)

![img](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/30-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90-%E6%96%B9%E6%A1%88%E5%9B%9B%E7%A4%BA%E4%BE%8B.jpg)

- 读者- 写者问题
  - 读者-写者的问题描述：
    - 「读-读」允许：同一时刻，允许多个读者同时读
    - 「读-写」互斥：没有写者时读者才能读，没有读者时写者才能写
    - 「写-写」互斥：没有其他写者时，写者才能写、
  - 解决方案
    - 公平策略：
      - 优先级相同；
      - 写者、读者互斥访问；
      - 只能一个写者访问临界区；
      - 可以有多个读者同时访问临界资源
  - 代码实现
    - ![img](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/34-%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85-%E6%96%B9%E6%A1%88%E4%B8%89%E7%A4%BA%E4%BE%8B.jpg)

# 5.7 死锁

## 5.7.1 **死锁满足的条件**

- 互斥条件   **多个线程不能同时使用同一个资源**
  - ![img](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/%E4%BA%92%E6%96%A5%E6%9D%A1%E4%BB%B6.png)
- 持有并等待条件  **线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1**
  - ![img](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/%E6%8C%81%E6%9C%89%E5%B9%B6%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6.png)
- 不可剥夺条件  ，**在自己使用完之前不能被其他线程获取**
  - ![img](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/%E4%B8%8D%E5%8F%AF%E5%89%A5%E5%A4%BA%E6%9D%A1%E4%BB%B6.png)
- 环路等待条件  **两个线程获取资源的顺序构成了环形链**
  - ![img](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/%E7%8E%AF%E8%B7%AF%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6.png)

## 5.7.2 **找到死锁**

- `pstack`  

  - ```bash
    $ pstack pid    
    $ pstack 87746//多次输出信息都没有变化，那么可能大概率发生了死锁
    ```

- `gbd`

  - ```bash
    $ gdb -p 87746 
    // 打印进程信息
    ```

## 5.7.3 **避免死锁**

- **顺序 获取资源**

  - **不同线程按照 相同的顺序去获取资源**

  - 例子

    - 死锁  **获取资源的顺序不一样**

      - ```c++
        //线程函数 A   先获取 A 锁 再获取 B 锁
        void *threadA_proc(void *data)
        {
            printf("thread A waiting get ResourceA \n");
            pthread_mutex_lock(&mutex_A);
            printf("thread A got ResourceA \n");
            
            sleep(1);
            
            printf("thread A waiting get ResourceB \n");
            pthread_mutex_lock(&mutex_B);
            printf("thread A got ResourceB \n");
        
            pthread_mutex_unlock(&mutex_B);
            pthread_mutex_unlock(&mutex_A);
            return (void *)0;
        }
        
        //线程函数 B   先获取B锁 再获取 A锁
        void *threadB_proc(void *data)
        {
            printf("thread B waiting get ResourceB \n");
            pthread_mutex_lock(&mutex_B);
            printf("thread B got ResourceB \n");
            
            sleep(1);
            
            printf("thread B waiting  get ResourceA \n");
            pthread_mutex_lock(&mutex_A);
            printf("thread B got ResourceA \n");
            
            pthread_mutex_unlock(&mutex_A);
            pthread_mutex_unlock(&mutex_B);
            return (void *)0;
        }
        ```

    - 不死锁   **获取资源的顺序 一致**

      - ```c++
        //线程 B 函数，同线程 A 一样，先获取互斥锁 A，然后获取互斥锁 B
        void *threadB_proc(void *data)
        {
            printf("thread B waiting get ResourceA \n");
            pthread_mutex_lock(&mutex_A);
            printf("thread B got ResourceA \n");
            
            sleep(1);
            
            printf("thread B waiting  get ResourceB \n");
            pthread_mutex_lock(&mutex_B);
            printf("thread B got ResourceB \n");
            
            pthread_mutex_unlock(&mutex_B);
            pthread_mutex_unlock(&mutex_A);
            return (void *)0;
        }
        ```

## 5.7.4 **总结**

- 简单来说，死锁问题的产生是由两个或者以上线程并行执行的时候，争夺资源而互相等待造成的。

- 死锁只有同时满足

  - **互斥**、

  - **持有并等待**、

  - **不可剥夺**、

  - **环路等待**

    这四个条件的时候才会发生。

- 所以要避免死锁问题，就是要破坏其中一个条件即可，最常用的方法就是使用资源有序分配法来破坏环路等待条件。

# 5.8 锁 的类别

![img](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/%E9%94%81%E4%B9%8B%E6%8F%90%E4%BE%9B.png)

## 5.8.1 互斥锁  

- ![img](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/%E4%BA%92%E6%96%A5%E9%94%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png)

- **失败操作**：

  - 互斥锁加锁失败时，会从用户态陷入到内核态，存在一定的性能开销成本

  - **互斥锁**加锁失败后，线程会**释放 CPU** ，给其他线程；

    

- **不足**：

  - 失败后需要利用 **内核态**  进行辅助操作， 线程 再释放性能时候， 
  - 进行上下文切换时 回增加到系统开销

## 5.8.2 自旋锁

- **引入原因**：
  - 当 被锁住的 **执行代码 时间很小时**， 使用 互斥锁 不太适合
  - 采用  **自旋锁 使其在 用户态中 进行加锁 和 解锁 操作** 可以减少上下文交换操作 ，减少开销
- **失败操作**
  - **自旋锁则用「忙等待」来应对**。

## 5.8.3 读写锁

- **使用场景**
  - **读写锁在读多写少的场景，能发挥出优势**
- **实现原理：**  
  - ​		当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。
  - ​        但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。
- **读写锁的 分类**： **区别在于 写锁等待时候的优先级**
  - **读优先锁**        读写进程同时 阻塞时候， 读优先
    - ![img](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/%E8%AF%BB%E4%BC%98%E5%85%88%E9%94%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png)
  - **写优先锁**    读写进程同时进行阻塞时， 写优先
    - ![img](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/%E5%86%99%E4%BC%98%E5%85%88%E9%94%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png)



## 5.8.4 乐观锁 和 悲观锁

- **区别  加锁的顺序** 
  - **乐观锁**
    - **先修改完共享资源**，再验证这段时间内有没有发生冲突，**如果没有其他**线程在**修改资源**，那么**操作完成**，如果发现有**其他线程已经修改**过这个资源，就**放弃本次操作**。
  - **悲观锁**
    - **多线程同时修改共享资源的概率比较高**，于是很容易出现冲突，所以访问共享资源前，**先要上锁**。

- **使用场景**
  - 乐观锁
    - 多人同时编辑时， 使用悲观锁 会限制编辑人数
    - 乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以**只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。**
  - 悲观锁
    - 互斥锁、自旋锁、读写锁，都是属于悲观锁

## 5.9 一个进程 最多可以创建 多少个 线程 

好了，简单总结下：

- 32 位系统，用户态的虚拟空间只有 3G，如果创建线程时分配的栈空间是 10M，那么一个进程最多只能创建 300 个左右的线程。
- 64 位系统，用户态的虚拟空间大到有 128T，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制。

## 5.10 线程崩溃了  进程一定会崩溃么

- 肯定 
  - 因为在进程中，**各个线程的地址空间是共享的**，既然是共享，那么某个**线程对地址的非法访问就会导致内存的不确定性**，进而可能会**影响到其他线程**，这种操作是危险的，操作系统会认为这很可能导致一系列严重的后果，**于是干脆让整个进程崩溃**
  - ![img](./%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/17be94f342ea4e49a227b195845880fd.jpeg)

## 5.11 信号  处理崩溃

- 处理流程：

  - CPU 执行正常的进程指令

  - 调用 kill 系统调用向进程发送信号

  - 进程收到操作系统发的信号，CPU 暂停当前程序运行，并将控制权转交给操作系统

  - 调用 kill 系统调用向进程发送信号（假设为 11，即 SIGSEGV，一般非法访问内存报的都是这个错误）

  - **操作系统根据情况执行相应的信号处理程序（函数），一般执行完信号处理程序逻辑后会让进程退出**









