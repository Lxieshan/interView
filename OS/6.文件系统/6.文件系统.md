文件系统

![img](./6.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.assets/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E6%8F%90%E7%BA%B2.png)

# 6. 文件系统的组成

## 6.1 文件的结构

- 索引节点
  - 索引节点的 用来记录文件的信息
  - 索引节点是文件的唯一表示
  - 索引节点占用空间
- 目录项
  - **目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存**。

- 目录
  - 目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。

- 文件系统 的存储

  - ![img](./6.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.assets/%E7%9B%AE%E5%BD%95%E9%A1%B9%E5%92%8C%E7%B4%A2%E5%BC%95%E5%85%B3%E7%B3%BB%E5%9B%BE.png)

  - **扇区**
    - 磁盘的最小单位 512B
    - 内存 多次访问 扇区效率低下
  - **逻辑块**
    - 多个扇区组合在一起

- 格式化 操作
  - 磁盘进行格式化的时候，会被分成三个存储区域，分别是超级块、索引节点区和数据块区。
    - ***超级块***，用来存储文件系统的详细信息，比如块个数、块大小、空闲块等等。
    - ***索引节点区***，用来存储索引节点；
    - ***数据块区***，用来存储文件或目录数据；
  - 不可能把超级块和索引节点区全部加载到内存，这样内存肯定撑不住，所以只有当需要使用的时候，才将其加载进内存，它们加载进内存的时机是不同的：
    - **超级块**：当文件系统挂载时进入内存；
    - **索引节点区**：当文件被访问时进入内存；



## 6.2 虚拟文件系统

- 文件类型多，OS对其进行统一接口调用

  ![img](./6.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.assets/%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png)

- **文件系统分类**
  - ***磁盘的文件系统***，它是直接把数据存储在磁盘中，比如 Ext 2/3/4、XFS 等都是这类文件系统。
  - ***内存的文件系统***，这类文件系统的数据不是存储在硬盘的，而是占用内存空间，我们经常用到的 `/proc` 和 `/sys` 文件系统都属于这一类，读写这类文件，实际上是读写内核中相关的数据。
  - ***网络的文件系统***，用来访问其他计算机主机数据的文件系统，比如 NFS、SMB 等等。

## 6.3 **文件的使用**

​	

- ![write 的过程](./6.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.assets/%E5%86%99%E5%88%B0%E7%A3%81%E7%9B%98%E8%BF%87%E7%A8%8B.png)

- **操作系统操作**

  - 每个进程都有一个 打开文件表
    - 表中每一项都表示文件描述符（表示打开文件的标识）

  - ![打开文件表](./6.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.assets/%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E8%A1%A8.png)



- **读文件**
  - 当用户进程从文件读取 1 个字节大小的数据时，
    - 文件系统则需要获取**字节所在的数据块**，
    - 再返回**数据块对应的**用户进程所需的**数据部分**。
- **写文件**
  - 当用户进程把 1 个字节大小的数据写进文件时，
    - 文件系统则找到需要写入数据的数据块的位置，
    - 然后修改数据块中对应的部分，
    - 最后再把数据块写回磁盘。



## 6.4 文件存储

### 6.4.1 **连续空间**



- ![连续空间存放方式](./6.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.assets/%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F.png)
- **优点**
  - 便于查询
- **缺点**
  - 后续增删操作 困难，易造成文件碎片化
  - ![磁盘碎片](./6.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.assets/%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F-%E7%A3%81%E7%9B%98%E7%A2%8E%E7%89%87.png)

### 6.4.2 **非连续空间**

- **链式**
  - **隐式链表 （链表节点 前后节点 存放在数据块中）**
    - ![隐式链表](./6.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.assets/%E9%9D%9E%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F-%E9%93%BE%E8%A1%A8%E6%96%B9%E5%BC%8F.png)
    - **缺点**
      - 无法直接访问数据块
      - 通过指针顺序访问
      - 数据块中指针 会消耗一定空间
  - **显示链表** （**有单独一张表，记录数据库的前后节点**）
    - ![显式链接](./6.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.assets/%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E8%A1%A8.png)
  - **优点**
    - 提高了访问速度，降低了访问次数
  - **缺点**
    - 整张表需放进内存中访问，如果表太大，无法一次性读入
    - 不适合大磁盘

### 6.4.3 **索引式**

- 显式链接 只能快速确定 文件的起始位置 文件的后续还需进行遍历操作
- 为了解决这个问题， 引入 索引 存储
- 索引的实现是为每个文件创建一个「**索引数据块**」，里面存放的是**指向文件数据块的指针列表**，
- ![索引的方式](./6.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.assets/%E9%9D%9E%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F-%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F.png)

- 优点：
  - 文件的创建、增大、缩小很方便；
  - 不会有碎片的问题；
  - 支持顺序读写和随机读写；

- 缺点：
  - 和 显式链式 一样 不适合 大文件

### 6.4.4 链式索引块

​		**在索引数据块留出一个存放下一个索引数据块的指针**，

![链式索引块](./6.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.assets/%E9%93%BE%E5%BC%8F%E7%B4%A2%E5%BC%95%E5%9D%97.png)

- 缺点
  - 中间损坏，后续的文件也无法使用了

### 6.4.5 多级索引

​		实现方式是**通过一个索引块来存放多个索引数据块**，一层套一层索引

![多级索引块](./6.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.assets/%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95%E5%9D%97.png)

### 6.4.6 总结对比

![img](./6.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.assets/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83.png)

## 6.5 空闲空间管理

- **空闲表**

  ![空闲表法](./6.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.assets/%E7%A9%BA%E9%97%B2%E8%A1%A8%E6%B3%95.png)

- **空闲链表法**

  ![空闲链表法](./6.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.assets/%E7%A9%BA%E9%97%B2%E5%9D%97%E9%93%BE%E8%A1%A8.png)

- **位图法**

  ​        位图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。

  ​         当值为 0 时，表示对应的盘块空闲，值为 1 时，表示对应的盘块已分配。它形式如下：

```c++
1111110011111110001110110111111100111 ...
```



## 6.6 文件系统的结构

- 大文件的存储  **块组**

  ![img](./6.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.assets/%E5%9D%97%E7%BB%84.png)

## 6.7 目录的存储

​		**普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息。**

![目录格式哈希表](./6.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.assets/%E7%9B%AE%E5%BD%95%E5%93%88%E5%B8%8C%E8%A1%A8.png)

​		目录查询是通过在磁盘上反复搜索完成，需要不断地进行 I/O 操作，开销较大。所以，为了减少 I/O 操作，把当前使用的文件目录缓存在内存，以后要使用该文件时只要在内存中操作，从而降低了磁盘操作次数，提高了文件系统的访问速度。

## 6.8 软链接 和 硬链接 

- 软链接  创建了一个 别名 
  - 文件删除后， 软链接还存在， 
  - ![软链接](./6.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.assets/%E8%BD%AF%E9%93%BE%E6%8E%A5.png)
- 硬链接  多个链接直接指向同一个文件
  - 只有删除文件的 所有 硬链接 和 文件本身，系统才会彻底删除该文件
  - ![硬链接](./6.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.assets/%E7%A1%AC%E9%93%BE%E6%8E%A5-2.png)



## 6.9 文件 I/O



![img](./6.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.assets/%E5%90%8C%E6%AD%A5VS%E5%BC%82%E6%AD%A5IO.png)

### 6.9.1 是否缓冲  

- **缓冲 I/O**
  - 利用的是**标准库的缓存实现文件的加速访问**，而**标准库再通过系统调用访问文件**。
- **非缓冲 I/O**
  - 直接通过系统调用访问文件，不经过标准库缓存。

### 6.9.2 直接与非直接

- **直接 I/O**
  - 不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘。
- **非直接 I/O**
  - 读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。

### 6.9.3 阻塞与非阻塞  同步与异步

- **阻塞**
  - ![阻塞 I/O](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E9%98%BB%E5%A1%9E%20I_O.png)****
- **非阻塞**
  - ![非阻塞 I/O](./6.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.assets/%E9%9D%9E%E9%98%BB%E5%A1%9E%20I_O%20.png)

- **I/O 多路复用**
- ![I/O 多路复用](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E5%9F%BA%E4%BA%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%20I_O%20%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png)
- **异步 I/O**
  - ![异步 I/O](./6.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.assets/%E5%BC%82%E6%AD%A5%20I_O.png)

​		阻塞 I/O 好比，你去饭堂吃饭，但是饭堂的菜还没做好，然后你就一直在那里等啊等，等了好长一段时间终于等到饭堂阿姨把菜端了出来（数据准备的过程），但是你还得继续等阿姨把菜（内核空间）打到你的饭盒里（用户空间），经历完这两个过程，你才可以离开。

​		非阻塞 I/O 好比，你去了饭堂，问阿姨菜做好了没有，阿姨告诉你没，你就离开了，过几十分钟，你又来饭堂问阿姨，阿姨说做好了，于是阿姨帮你把菜打到你的饭盒里，这个过程你是得等待的。

​		基于非阻塞的 I/O 多路复用好比，你去饭堂吃饭，发现有一排窗口，饭堂阿姨告诉你这些窗口都还没做好菜，等做好了再通知你，于是等啊等（`select` 调用中），过了一会阿姨通知你菜做好了，但是不知道哪个窗口的菜做好了，你自己看吧。于是你只能一个一个窗口去确认，后面发现 5 号窗口菜做好了，于是你让 5 号窗口的阿姨帮你打菜到饭盒里，这个打菜的过程你是要等待的，虽然时间不长。打完菜后，你自然就可以离开了。

​		异步 I/O 好比，你让饭堂阿姨将菜做好并把菜打到饭盒里后，把饭盒送到你面前，整个过程你都不需要任何等待。

### 6.9.4   进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？

 不会 page cache 

