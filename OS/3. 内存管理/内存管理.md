[TOC]

内存管理

![img](./%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/970ec527d1c1417eab0d3246e77405f9.png)

# 1. 虚拟内存

两种地址的概念：

- 我们程序所使用的内存地址叫做**虚拟内存地址**（*Virtual Memory Address*）
- 实际存在硬件里面的空间地址叫**物理内存地址**（*Physical Memory Address*）。

​		操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，如下图所示：

![img](./%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/72ab76ba697e470b8ceb14d5fc5688d9.png)

# 2. 管理虚拟地址 与 物理地址 关系

## 2.1 内存分段

![img](./%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/a9ed979e2ed8414f9828767592aadc21.png)

## 2.2 内存分页

​		内存分段 易产生碎片，需要用到内存交换，使用swap 空间，**如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。**

​		为解决内存交换问题，提出内存分页

![img](./%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/7884f4d8db4949f7a5bb4bbd0f452609.png)

## 2.3 段页表

![img](./%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/8904fb89ae0c49c4b0f2f7b5a0a7b099.png)

- 第一次访问段表，得到页表起始地址；
- 第二次访问页表，得到物理页号；
- 第三次将物理页号与页内位移组合，得到物理地址。

# 3. 虚拟内存的作用

- 第一，虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。
- 第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。
- 第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。

# 4. malloc 如何分配内存

## 4.1 用户空间 和 内核空间

![图片](./%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/c88bda5db60029f3ea57e4306e7da936.jpeg)

## 4.2 申请方式

1. brk();

![img](./%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/brk%E7%94%B3%E8%AF%B7.png)

2. mmap()

   ![img](./%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/mmap%E7%94%B3%E8%AF%B7.png)

- 如果用户分配的内存小于 128 KB，则通过 brk() 申请内存；
- 如果用户分配的内存大于 128 KB，则通过 mmap() 申请内存；
  - 不同版本 对于 阈值的定义不同

## 4.3 malloc分配的是 虚拟内存

## 4.4 malloc 分配的内存大小

# 5. 内存回收

![img](./%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/e069da38c4b54ee98a585a176e2c342f.png)

## 5.1 分配过程

![img](./%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/2f61b0822b3c4a359f99770231981b07.png)

## 5.2 阈值

- 页最小阈值（pages_min）；
- 页低阈值（pages_low）；
- 页高阈值（pages_high）；

这三个内存阈值会划分为四种内存使用情况，如下图：

![img](./%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/166bc9f5b7c545d89f1e36ab8dd772cf.png)

## 5.3 OOM

​		内存溢出(Out Of Memory，简称OOM)是指应用系统中存在无法回收的内存或使用的内存过多，最终使得程序运行要用到的内存大于能提供的最大内存。

## 5.3 SWAP 机制

- 如果没有 Swap 分区，因为物理空间不够，进程会被操作系统杀掉，原因是 OOM（内存溢出）；
- 如果有 Swap 分区，即使物理内存只有 4GB，程序也能正常使用 8GB 的内存，进程可以正常运行；

# 6. 内存申请

![img](./%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/3a6cb4e3f27241d3b09b4766bb0b1124.png)

- 4GB 物理内存的机器上，申请 8GB 内存
  - 32位系统
    - 32 位操作系统，进程最多只能申请 3 GB 大小的虚拟内存空间，所以进程申请 8GB 内存的话，在申请虚拟内存阶段就会失败
  - 64位系统
    - 64 位操作系统，进程可以使用 128 TB 大小的虚拟内存空间，所以进程申请 8GB 内存是没问题的，因为进程申请内存是申请虚拟内存，只要不读写这个虚拟内存，操作系统就不会分配物理内存

# 7. 缓存失效 和 缓存污染

![img](./%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93%E6%8F%90%E7%BA%B2.png)

## 7.1 缓存

- Linux

  ![img](./%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png)

- Mysql

  ![img](./%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/%E7%BC%93%E5%86%B2%E6%B1%A0.drawio.png)

## 7.2 LRU 算法

​		LRU（Least recently used）算法，是用「链表」作为数据结构来实现的，链表头部的数据是最近使用的，而链表末尾的数据是最久没被使用的。

​		那么，当空间不够了，就淘汰最久没被使用的节点，也就是链表末尾的数据，从而腾出内存空间。

​		缺点：

- 预读失效导致缓存命中率下降；
- 缓存污染导致缓存命中率下降；

## 7.3 预读机制

​		当操作系统通过I/O性能大于用户需求时，系统会采取预加载的策略，将用户可能需要的数据及其周围的内容提前加载到内存中。

​		这是因为一般情况下，数据访问具有连续性，即相邻的数据很可能会被连续地访问。

​		通过这种操作，系统能够降低I/O操作的次数，减少从磁盘读取数据的延迟，从而提高整体系统性能。

## 7.4  缓存污染

​		当我们在批量读取数据的时候，由于数据被访问了一次，这些大量数据都会被加入到「活跃 LRU 链表」里，然后之前缓存在活跃 LRU 链表（或者 young 区域）里的热点数据全部都被淘汰了，

​		**如果这些大量的数据在很长一段时间都不会被访问的话，那么整个活跃 LRU 链表（或者 young 区域）就被污染了**。

## 7.5 解决缓存污染

​		为了避免「缓存污染」造成的影响，Linux 操作系统和 MySQL Innodb 存储引擎分别提高了升级为热点数据的门槛：

- Linux 操作系统：在内存页被访问**第二次**的时候，才将页从 inactive list 升级到 active list 里。

- MySQL Innodb：在内存页被访问

  第二次

  的时候，并不会马上将该页从 old 区域升级到 young 区域，因为还要进行

  停留在 old 区域的时间判断

  - 如果第二次的访问时间与第一次访问的时间**在 1 秒内**（默认值），那么该页就**不会**被从 old 区域升级到 young 区域；
  - 如果第二次的访问时间与第一次访问的时间**超过 1 秒**，那么该页就**会**从 old 区域升级到 young 区域；

​		通过提高了进入 active list （或者 young 区域）的门槛后，就很好了避免缓存污染带来的影响。

# 8. Liunx 虚拟内存

![本文概要.png](./%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/1ff04f9ea15582324af7849f3c5f9dab.png)

## 8.1 虚拟内存 

- 32位

  - ![image.png](./%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/ffb6e1727e2289f142f6a2a6291cd68c.png)

- 64位

  ![image.png](./%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/532e6cdf4899588f8b873b6435cba2d8.png)

## 8.2 虚拟内存空间管理

![image.png](./%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/b1402bf81de260b86ce0cb4c19cd4330-20230309233758868.png)